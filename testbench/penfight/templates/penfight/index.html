<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pen Fight Game</title>
<style>
    body {
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        font-family: 'Arial', sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        overflow: hidden;
    }
    
    #gameContainer {
        position: relative;
        border: 4px solid #333;
        border-radius: 10px;
        background: #f0f0f0;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    
    #gameCanvas {
        display: block;
        border-radius: 6px;
        cursor: crosshair;
        touch-action: none;
    }
    
    #gameOverScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: none;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        border-radius: 6px;
    }
    
    #gameOverContent {
        background: white;
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    
    #gameOverContent h2 {
        color: #333;
        margin-bottom: 10px;
        font-size: 2em;
    }
    
    #gameOverContent p {
        color: #666;
        margin-bottom: 30px;
        font-size: 1.2em;
    }
    
    .button {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        border: none;
        padding: 12px 25px;
        margin: 0 5px;
        border-radius: 8px;
        font-size: 1em;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    #turnIndicator {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px 15px;
        border-radius: 5px;
        font-weight: bold;
        font-size: 1em;
    }
    
    #instructions {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 0.9em;
        max-width: 200px;
    }
</style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="turnIndicator">Player 1's Turn</div>
    <div id="instructions">
        Tap/click and drag your pen to flick it. Knock the opponent off the table!
    </div>
    <div id="gameOverScreen">
        <div id="gameOverContent">
            <h2>Game Over</h2>
            <p id="winnerText">Player 1 Wins!</p>
            <button class="button" onclick="restartGame()">Restart</button>
            <button class="button" onclick="quitGame()">Quit</button>
        </div>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const gameOverScreen = document.getElementById('gameOverScreen');
const winnerText = document.getElementById('winnerText');
const turnIndicator = document.getElementById('turnIndicator');

let pen1, pen2;

// Game state
let gameState = {
    currentPlayer: 1,
    gameOver: false,
    winner: null,
    firstShot: [true, true],
    isDragging: false,
    dragStart: null,
    dragEnd: null
};

// Physics constants
const FRICTION = 0.98;
const ANGULAR_FRICTION = 0.95;
const COLLISION_DAMPING = 0.8;
const FORCE_SCALE = 0.015; // Scale force relative to canvas size

class Pen {
    constructor(x, y, color, player) {
        this.x = x;
        this.y = y;
        this.width = canvas.width * 0.1;
        this.height = canvas.height * 0.02;
        this.angle = 0;
        this.vx = 0;
        this.vy = 0;
        this.angularVelocity = 0;
        this.color = color;
        this.player = player;
        this.mass = 1;
    }

    update() {
        this.vx *= FRICTION;
        this.vy *= FRICTION;
        this.angularVelocity *= ANGULAR_FRICTION;

        this.x += this.vx;
        this.y += this.vy;
        this.angle += this.angularVelocity;

        if (Math.abs(this.vx) < 0.01) this.vx = 0;
        if (Math.abs(this.vy) < 0.01) this.vy = 0;
        if (Math.abs(this.angularVelocity) < 0.001) this.angularVelocity = 0;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
        ctx.fillStyle = '#333';
        ctx.fillRect(this.width/2 - this.width*0.06, -this.height/2, this.width*0.06, this.height);
        ctx.fillStyle = 'white';
        ctx.fillRect(-this.width/2 + this.width*0.125, -this.height*0.15, this.width*0.25, this.height*0.3);
        ctx.restore();
    }

    getCorners() {
        const cos = Math.cos(this.angle);
        const sin = Math.sin(this.angle);
        const hw = this.width / 2;
        const hh = this.height / 2;
        return [
            { x: this.x + (-hw*cos - -hh*sin), y: this.y + (-hw*sin + -hh*cos) },
            { x: this.x + (hw*cos - -hh*sin), y: this.y + (hw*sin + -hh*cos) },
            { x: this.x + (hw*cos - hh*sin), y: this.y + (hw*sin + hh*cos) },
            { x: this.x + (-hw*cos - hh*sin), y: this.y + (-hw*sin + hh*cos) }
        ];
    }

    isOutOfBounds() {
        const corners = this.getCorners();
        let outside = 0;
        corners.forEach(c => { if(c.x<0||c.x>canvas.width||c.y<0||c.y>canvas.height) outside++; });
        return outside > 2;
    }

    applyForce(fx, fy, pointX, pointY) {
        this.vx += fx / this.mass;
        this.vy += fy / this.mass;

        const dx = pointX - this.x;
        const dy = pointY - this.y;
        const torque = dx * fy - dy * fx;
        this.angularVelocity += torque / (this.mass * 1000);

        const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
        const maxVel = canvas.width*0.02; // scale max velocity
        if(speed > maxVel){
            this.vx = (this.vx/speed)*maxVel;
            this.vy = (this.vy/speed)*maxVel;
        }
    }

    getBounds(){
        const c = this.getCorners();
        let minX=c[0].x,maxX=c[0].x,minY=c[0].y,maxY=c[0].y;
        c.forEach(p=>{ minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x); minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y); });
        return {minX,maxX,minY,maxY};
    }
}

function resizeCanvas(){
    const w = window.innerWidth*0.9;
    const h = w*0.75;
    canvas.width = w; canvas.height = h;
    if(!pen1 && !pen2){
        pen1 = new Pen(w*0.2,h/2,'#e74c3c',1);
        pen2 = new Pen(w*0.8,h/2,'#3498db',2);
    } else {
        pen1.x=w*0.2; pen1.y=h/2; pen1.width=w*0.1; pen1.height=h*0.02;
        pen2.x=w*0.8; pen2.y=h/2; pen2.width=w*0.1; pen2.height=h*0.02;
    }
}
window.addEventListener('resize',resizeCanvas);
resizeCanvas();

function getPointerPos(e){
    const rect = canvas.getBoundingClientRect();
    return {x:(e.touches?e.touches[0].clientX:e.clientX)-rect.left,
            y:(e.touches?e.touches[0].clientY:e.clientY)-rect.top};
}
function isPointInPen(x,y,pen){
    const dx=x-pen.x,dy=y-pen.y;
    const cos=Math.cos(-pen.angle), sin=Math.sin(-pen.angle);
    const lx=dx*cos - dy*sin, ly=dx*sin + dy*cos;
    return Math.abs(lx)<=pen.width/2 && Math.abs(ly)<=pen.height/2;
}
function getCurrentPlayerPen(){ return gameState.currentPlayer===1?pen1:pen2; }
function bothPensStopped(){
    return Math.abs(pen1.vx)<0.01 && Math.abs(pen1.vy)<0.01 && Math.abs(pen1.angularVelocity)<0.001 &&
           Math.abs(pen2.vx)<0.01 && Math.abs(pen2.vy)<0.01 && Math.abs(pen2.angularVelocity)<0.001;
}
function checkCollision(p1,p2){
    const b1=p1.getBounds(), b2=p2.getBounds();
    return !(b1.maxX<b2.minX || b1.minX>b2.maxX || b1.maxY<b2.minY || b1.minY>b2.maxY);
}
function resolveCollision(p1,p2){
    const dx=p2.x-p1.x, dy=p2.y-p1.y, dist=Math.sqrt(dx*dx+dy*dy);
    if(dist===0) return;
    const nx=dx/dist, ny=dy/dist;
    const dvx=p2.vx-p1.vx, dvy=p2.vy-p1.vy;
    const dvn=dvx*nx + dvy*ny;
    if(dvn>0) return;
    const impulse=2*dvn/(p1.mass+p2.mass)*COLLISION_DAMPING;
    p1.vx+=impulse*p2.mass*nx; p1.vy+=impulse*p2.mass*ny;
    p2.vx-=impulse*p1.mass*nx; p2.vy-=impulse*p1.mass*ny;
    const overlap=(p1.width+p2.width)/2-dist;
    if(overlap>0){ const sepX=nx*overlap*0.5, sepY=ny*overlap*0.5; p1.x-=sepX; p1.y-=sepY; p2.x+=sepX; p2.y+=sepY; }
}

canvas.addEventListener('pointerdown', e=>{
    if(gameState.gameOver || !bothPensStopped()) return;
    const pos=getPointerPos(e); const pen=getCurrentPlayerPen();
    if(isPointInPen(pos.x,pos.y,pen)){
        gameState.isDragging=true; gameState.dragStart={x:pos.x,y:pos.y};
    }
});
canvas.addEventListener('pointermove', e=>{
    if(!gameState.isDragging) return;
    gameState.dragEnd=getPointerPos(e);
});
canvas.addEventListener('pointerup', e=>{
    if(!gameState.isDragging || gameState.gameOver) return;
    const pen=getCurrentPlayerPen();
    const pos=getPointerPos(e);
    if(gameState.dragStart){
        let fx=(gameState.dragStart.x-pos.x)*FORCE_SCALE*canvas.width;
        let fy=(gameState.dragStart.y-pos.y)*FORCE_SCALE*canvas.height;
        if(gameState.firstShot[gameState.currentPlayer-1]){ fx*=0.5; fy*=0.5; gameState.firstShot[gameState.currentPlayer-1]=false; }
        pen.applyForce(fx,fy,gameState.dragStart.x,gameState.dragStart.y);
        gameState.currentPlayer = gameState.currentPlayer===1?2:1;
        turnIndicator.textContent=`Player ${gameState.currentPlayer}'s Turn`;
    }
    gameState.isDragging=false; gameState.dragStart=null; gameState.dragEnd=null;
});

function checkGameOver(){
    if(pen1.isOutOfBounds()){ gameState.gameOver=true; gameState.winner=2; }
    else if(pen2.isOutOfBounds()){ gameState.gameOver=true; gameState.winner=1; }
    if(gameState.gameOver){ winnerText.textContent=`Player ${gameState.winner} Wins!`; gameOverScreen.style.display='flex'; }
}

function drawTrajectoryLine(){
    if(gameState.isDragging && gameState.dragStart && gameState.dragEnd){
        ctx.strokeStyle='rgba(255,0,0,0.7)'; ctx.lineWidth=3; ctx.setLineDash([5,5]);
        ctx.beginPath(); ctx.moveTo(gameState.dragEnd.x,gameState.dragEnd.y);
        ctx.lineTo(gameState.dragStart.x,gameState.dragStart.y); ctx.stroke(); ctx.setLineDash([]);
        const angle=Math.atan2(gameState.dragStart.y-gameState.dragEnd.y,gameState.dragStart.x-gameState.dragEnd.x);
        const len=canvas.width*0.03;
        ctx.beginPath();
        ctx.moveTo(gameState.dragStart.x,gameState.dragStart.y);
        ctx.lineTo(gameState.dragStart.x-len*Math.cos(angle-Math.PI/6),gameState.dragStart.y-len*Math.sin(angle-Math.PI/6));
        ctx.moveTo(gameState.dragStart.x,gameState.dragStart.y);
        ctx.lineTo(gameState.dragStart.x-len*Math.cos(angle+Math.PI/6),gameState.dragStart.y-len*Math.sin(angle+Math.PI/6));
        ctx.stroke();
    }
}

function gameLoop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(!gameState.gameOver){
        pen1.update(); pen2.update();
        if(checkCollision(pen1,pen2)) resolveCollision(pen1,pen2);
        checkGameOver();
    }
    pen1.draw(); pen2.draw(); drawTrajectoryLine();
    turnIndicator.style.opacity = bothPensStopped()&&!gameState.gameOver?'1':'0.5';
    canvas.style.cursor = bothPensStopped()&&!gameState.gameOver?'crosshair':'wait';
    requestAnimationFrame(gameLoop);
}

function restartGame(){
    gameState.currentPlayer=1; gameState.gameOver=false; gameState.winner=null;
    gameState.firstShot=[true,true]; gameState.isDragging=false;
    gameState.dragStart=null; gameState.dragEnd=null;
    pen1.x=canvas.width*0.2; pen1.y=canvas.height/2; pen1.angle=0; pen1.vx=0; pen1.vy=0; pen1.angularVelocity=0;
    pen2.x=canvas.width*0.8; pen2.y=canvas.height/2; pen2.angle=0; pen2.vx=0; pen2.vy=0; pen2.angularVelocity=0;
    gameOverScreen.style.display='none'; turnIndicator.textContent="Player 1's Turn";
}

function quitGame(){
    const gameContainer = document.getElementById('gameContainer');
    gameContainer.innerHTML=`<div style="display:flex;justify-content:center;align-items:center;height:100%;flex-direction:column;font-family:Arial,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:white;">
    <h1>Thank You for Playing!</h1><p>Come back soon for another match!</p></div>`;
}

gameLoop();
</script>
</body>
</html>
